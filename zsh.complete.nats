#compdef nats -value-,NATS_CONTEXT,-default-

# Recommendation: place NATS_CONTEXT into your fake-parameters zstyle
#
# Eg:
#   zstyle ':completion:*' fake-parameters \
#     AWS_PROFILE DOCKER_CONTEXT NATS_CONTEXT
#
# You can set the standard zstyle 'verbose' to true such that it applies
# to us, to see context descriptions.
# You can set the zstyle generally with custom keybindings, or enable it on a
# per-command basis; eg:
#   zstyle ':completion::complete:nats:*' verbose true
#   zstyle ':completion::complete:-value-,NATS_CONTEXT,:' verbose true
#
# The approach used to get the descriptions is slightly fragile, based upon raw
# text-line parsing of the JSON context files.  If we change that storage at all,
# and have to switch back to invoking jq once per file, then we will unfortunately
# have to move the zstyle guard across to 'extra-verbose' instead.  It's only the
# mapfile technique which lets us keep this as only being 'verbose'.
#

local curcontext="$curcontext" state line expl cmdword
local nctx
local -a nats_contexts nats_commands nats_sub nats_flags described_contexts
local -A nats_decorate_flags_desc nats_decorate_flags_next nats_decorate_flags_mutex
local -i nats_verbose=0

# extra-verbose is documented as for features which will slow completion speed.
# verbose is just for being more wordy.
# If we have to revert back to the jq invocation approach, then we should use
# extra-verbose as our conditional here.
if zstyle -t ":completion:${curcontext}:" verbose; then
  nats_verbose=1
fi

local -ra want_context=(
  context:edit
  context:info
  context:rm
  context:select
  context:show
  context:validate
)

local -r nats_ctxdir="${XDG_CONFIG_HOME:-$HOME/.config}/nats/context"

nats_contexts=( "$nats_ctxdir"/*(N:t:r) )

# *IF* we revert back to using jq, then:
# TODO: come up with a cache expiration strategy and integrate this with use-cache
# or at least a global variable.
#
# The performance difference scales rapidly with number of contexts.
#
(( ${+functions[_nats_context_names]} )) ||
_nats_context_names() {
  if (( nats_verbose )); then
    described_contexts=()
    for nctx in "${nats_contexts[@]}"; do
      # This is the more reliable but much slower method, using repeated invocations of jq:
      #described_contexts+=("${nctx//:/\\:}:$(_call_program jq "jq -r .description < \"${(q)nats_ctxdir}/${(q)nctx}.json\"")")
      # This, thanks to Bart Schaefer, is a zsh-native approach which will work
      # as long as the JSON files are one field per line; if we start storing
      # the JSON data as single-line blobs then we will need to switch back to
      # the heavy-weight jq approach:
      described_contexts+=("${nctx//:/\\:}:${${${${(@M)${(f)mapfile[$nats_ctxdir/$nctx.json]}:#[[:space:]]##\"description\":*}#*: \"}%,}%\"}")
    done
    _describe nats-contexts described_contexts
  else
    _wanted nats-contexts expl 'nats contexts' compadd "$@" -- "${nats_contexts[@]}"
  fi
}

case "$service" in
  *,NATS_CONTEXT,*)
    _nats_context_names
    return 0
    ;;
esac

nats_decorate_flags_desc=( # this assumes zsh is-at-least 5.5
	[context]='NATS user context'
	[tlscert]='TLS client auth public certificate'
	[tlskey]='TLS client auth private key'
	[tlsca]='TLS CA bundle to verify server cert'
	[creds]='NATS credentials file to use for authentication'
	[nkey]='filename containing NKey private key'
	[user]='NATS username to authenticate as'
	[password]='Password for NATS user'
	[trace]='Trace API interactions'
	[server]='NATS server URL to connect to'
	[timeout]='time to wait for responses from NATS'

	# common sub-command flags
	[yaml]='Produce YAML format output'
	[json]='Produce JSON format output'
)
nats_decorate_flags_mutex=(
	[server]='"(--server -s)"{-s,--server=}'
)
nats_decorate_flags_next=(
	[tlscert]='_files' [tlskey]='_files' [tlsca]='_files'
	[creds]='_files' [nkey]='_files'
	[user]=' ' [password]=' '
	[server]=' '
	[timeout]=' '
	[context]='_nats_context_names'
)

# We populate a complete set first, so that even if we don't have more details below,
# we can still tab-complete it; it will just be missing some data
nats_commands=( $(_call_program nats-completion-bash "${(q)words[1]} --completion-bash ${(qq)words[1]}") )

# Most flags can appear anywhere; this is not a git-style "top command flags"
# vs "subcommand flags", but instead "one pool of flags which gains extra
# entries for some subcommands".
nats_flags=( $(_call_program nats-completion-bash "${(q)words[1]} --completion-bash ${(qq)words[1]} --") )

(( ${+functions[_nats_decorate_flags]} )) ||
_nats_decorate_flags() {
  #zle -M "decorating ..."; zle -R
  local flag directive
  local -a expanded
  for flag in "${(@k)nats_decorate_flags_desc}"; do
    (( nats_flags[(I)--$flag] )) || continue
    directive=''
    if ! (( $+nats_decorate_flags_mutex[$flag] )); then
      directive="--$flag"
      if (( $+nats_decorate_flags_next[$flag] )); then
        directive+="="
      fi
    fi
    directive+="[${nats_decorate_flags_desc[$flag]}]:${nats_decorate_flags_desc[$flag]}"
    if (( $+nats_decorate_flags_next[$flag] )); then
      directive+=":${nats_decorate_flags_next[$flag]}"
    fi
    if (( $+nats_decorate_flags_mutex[$flag] )); then
      # This is safe because _we_ control all inputs to the eval, nothing comes from the command
      eval "expanded=(${nats_decorate_flags_mutex[$flag]})"
      nats_flags[(I)--$flag]=(${^expanded}"$directive")
    else
      nats_flags[(I)--$flag]="$directive"
    fi
  done
}

_nats_decorate_flags

cmdword="${words[1]}"

_arguments -C \
  "${nats_flags[@]}" \
  '(-): :->commands' \
  '(-)*:: :->after-command' && return

case "$state" in
(commands)
  _describe -t nats-commands 'nats commands' nats_commands
  return
  ;;
(after-command)
  curcontext=${curcontext%:*:*}:nats-$words[1]:
  nats_sub=( $(_call_program nats-completion-bash "${(q)cmdword} --completion-bash ${${(qq)words[@]}}") )
  if [[ ${#nats_sub} -eq 0 ]]; then
    # terminal
    nats_flags=( $(_call_program nats-completion-bash "${(q)cmdwords} --completion-bash ${${(qq)words[@]}} --") )
    _nats_decorate_flags
    # We use -2 to drop the last word, which might be mid-word if expanding again after a few letters.
    nctx="${(j,:,)words[1,-2]}"
    if (( ${want_context[(Ie)$nctx]} )); then
      _arguments -C "${nats_flags[@]}" '(-): :->commands' '(-)*:: :_nats_context_names' && return
    else
      _arguments -C "${nats_flags[@]}" '(-): :->commands' '(-)*:: :->after-command' && return
    fi
  else
    _describe -t nats-sub-commands 'nats sub-commands' nats_sub
  fi
  ;;
esac
